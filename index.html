<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Whitelist Service — Admin</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root{--bg1:#00b4ff;--bg2:#ff6ec7}
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; background: linear-gradient(90deg,var(--bg1),var(--bg2)); color:#111; margin:0; padding:24px; }
    .container { max-width:1100px; margin:0 auto; display:grid; grid-template-columns: 1fr 420px; gap:20px; align-items:start; }
    .card { background: white; padding:16px; border-radius:10px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); }
    header.card { grid-column: 1 / -1; display:flex; align-items:center; gap:12px; }
    header h1{ margin:0; font-size:18px }
    .small { font-size:13px; color:#666; margin-top:6px }
    label{ display:block; margin-top:8px; font-weight:600; font-size:13px}
    input, textarea, select, button { padding:8px; margin-top:6px; width:100%; box-sizing:border-box; border-radius:8px; border:1px solid #eee; font-size:14px }
    textarea{ min-height:120px; font-family:monospace }
    pre { background:#f6f6f6; padding:12px; border-radius:8px; overflow:auto; max-height:320px; }
    .row{ display:flex; gap:8px }
    .col{ flex:1 }
    .muted{ color:#666; font-size:13px }
    .btn-row{ display:flex; gap:8px; margin-top:10px }
    .note{ font-size:12px; color:#444; margin-top:8px }
    a.link{ color:var(--bg1); text-decoration:none; font-weight:600 }
    @media (max-width:980px){ .container{ grid-template-columns:1fr; } header.card{ flex-direction:column; align-items:flex-start } }
  </style>
</head>
<body>
  <div class="container">
    <header class="card">
      <div>
        <h1>Whitelist Service — Admin Panel</h1>
        <div class="small">Generate keys • Create personalized Lua wrappers • Manage keys and scripts</div>
      </div>
      <div style="margin-left:auto; text-align:right">
        <div class="muted">Server: <span id="serverDisplay">http://localhost:3000</span></div>
        <div class="small">Use the admin token in header <code>x-admin-token</code></div>
      </div>
    </header>

    <!-- Left column: Keys & Script generation -->
    <section class="card">
      <h3>Manage Keys</h3>
      <label>Admin token (x-admin-token)</label>
      <input id="admintoken" placeholder="paste admin token here" />
      <div class="row">
        <div class="col">
          <label>Count</label>
          <input id="count" type="number" value="1" />
        </div>
        <div class="col">
          <label>Expires in seconds (optional)</label>
          <input id="expires" type="number" placeholder="e.g., 86400 for 1 day" />
        </div>
      </div>
      <div class="btn-row">
        <button id="gen">Generate Key(s)</button>
        <button id="refresh">Refresh Keys</button>
      </div>
      <div class="note">Generated keys appear below. Keep admin token safe.</div>
      <h4 style="margin-top:14px">Latest keys</h4>
      <pre id="keys">Loading...</pre>

      <hr style="margin:18px 0">

      <h3>Generate personalized Lua script (manual)</h3>
      <label>Method</label>
      <select id="method">
        <option value="fetch">fetch (recommended — returns wrapper that fetches protected payload)</option>
        <option value="embed">embed (includes payload directly in wrapper)</option>
      </select>

      <label>Associated Key (optional)</label>
      <input id="assoc_key" placeholder="KEY (optional) - leave blank to generate after redemption" />

      <label>Expires in seconds (optional — for fetch tokens)</label>
      <input id="expires_script" placeholder="e.g., 3600" />

      <label>Original loader URL (ORIG_SRC)</label>
      <input id="orig_src" placeholder="https://example.com/original_loader.lua" />

      <label>Payload (the real loadstring or Lua payload you want protected)</label>
      <textarea id="payload" placeholder="Paste the real loadstring or Lua payload here"></textarea>

      <div class="btn-row">
        <button id="gen_script">Generate & Download .lua</button>
        <button id="preview_script">Preview Wrapper</button>
      </div>

      <div id="previewBox" style="display:none; margin-top:12px">
        <h4>Preview</h4>
        <pre id="previewText"></pre>
      </div>
    </section>

    <!-- Right column: Quick actions -->
    <aside class="card">
      <h3>Quick Actions</h3>

      <label>Fetch personalized script (by src_id)</label>
      <input id="quick_src" placeholder="src_id (from redeem response)" />
      <label>Key for fetch</label>
      <input id="quick_key" placeholder="user key" />
      <div class="btn-row">
        <button id="quick_fetch">Fetch Script</button>
        <button id="open_docs">Open Docs</button>
      </div>

      <hr style="margin:14px 0">

      <h4>Redeem helper (for testing)</h4>
      <label>Key</label>
      <input id="test_key" placeholder="KEY" />
      <label>Discord ID</label>
      <input id="test_discord" placeholder="123456789012345678" />
      <label>HWID</label>
      <input id="test_hwid" placeholder="hwid-123" />
      <div class="btn-row">
        <button id="test_redeem">Redeem</button>
        <button id="test_fetch_script">Redeem & Fetch Script</button>
      </div>

      <h4 style="margin-top:12px">Server responses</h4>
      <pre id="responseBox">No actions yet.</pre>
    </aside>

    <footer class="card" style="grid-column: 1 / -1; font-size:13px;">
      <div class="muted">Notes: This admin UI is for convenience and testing. Do not store ADMIN_TOKEN in client-side code for production. Use HTTPS in production. The personalized wrapper approach individualizes wrappers but cannot prevent users from copying runtime payloads.</div>
    </footer>
  </div>

<script>
  const SERVER = (new URL(location)).origin; // assumes served from same origin; override if different
  document.getElementById('serverDisplay').textContent = SERVER;

  async function api(path, opts={}) {
    const url = path.startsWith('http') ? path : SERVER + path;
    const res = await fetch(url, opts);
    if (!res.ok) {
      let err;
      try { err = await res.json(); } catch(e) { err = { error: res.statusText || res.status }; }
      throw err;
    }
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('text/plain')) return await res.text();
    return await res.json();
  }

  // Generate keys
  document.getElementById('gen').onclick = async () => {
    const t = document.getElementById('admintoken').value;
    const count = parseInt(document.getElementById('count').value||'1',10);
    const expires = parseInt(document.getElementById('expires').value||'0',10) || undefined;
    try {
      const j = await api('/api/admin/generate', {
        method:'POST',
        headers: { 'Content-Type':'application/json', 'x-admin-token': t },
        body: JSON.stringify({ count, expires_in_seconds: expires })
      });
      alert('Generated keys:\n' + JSON.stringify(j.generated, null, 2));
      refreshKeys();
    } catch(e){ alert('Error: ' + (e.error || JSON.stringify(e))); }
  };

  async function refreshKeys(){
    const t = document.getElementById('admintoken').value;
    try {
      const j = await api('/api/admin/keys', { headers: { 'x-admin-token': t }});
      document.getElementById('keys').textContent = JSON.stringify(j.keys, null, 2);
    } catch(e){
      document.getElementById('keys').textContent = 'Unauthorized - provide correct admin token above';
    }
  }
  document.getElementById('refresh').onclick = refreshKeys;
  refreshKeys();

  // Generate script (manual)
  document.getElementById('gen_script').onclick = async () => {
    const token = document.getElementById('admintoken').value;
    const method = document.getElementById('method').value;
    const assoc = document.getElementById('assoc_key').value || null;
    const expires = parseInt(document.getElementById('expires_script').value||'0',10) || undefined;
    const payload = document.getElementById('payload').value;
    const orig = document.getElementById('orig_src').value || '';

    if (!token) return alert('Provide admin token');
    if (!payload) return alert('Provide payload to protect');
    if (!orig) return alert('Provide ORIGINAL loader URL');

    try {
      const res = await fetch('/api/admin/generate-lua', {
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'x-admin-token': token },
        body: JSON.stringify({ method, key: assoc, payload, original_src: orig, expires_in_seconds: expires })
      });

      if (!res.ok) {
        const j = await res.json().catch(()=>({error:'unknown'}));
        return alert('Error: ' + (j.error || res.status));
      }

      const text = await res.text();
      const blob = new Blob([text], { type:'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'whitelist_client.lua'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      document.getElementById('responseBox').textContent = 'Generated script downloaded.';
    } catch(e) {
      document.getElementById('responseBox').textContent = 'Error: ' + (e.error || JSON.stringify(e));
    }
  };

  // Preview wrapper generation (client-side preview)
  document.getElementById('preview_script').onclick = () => {
    const method = document.getElementById('method').value;
    const payload = document.getElementById('payload').value;
    const orig = document.getElementById('orig_src').value || 'https://example.com/original_loader.lua';
    if (!payload) return alert('Provide payload to preview');
    if (method === 'embed') {
      const script = `-- EMBED PREVIEW (truncated)\n-- ORIGINAL SRC: ${orig}\n-- PAYLOAD LENGTH: ${payload.length}\n\n-- (payload omitted in preview)`;
      document.getElementById('previewText').textContent = script;
    } else {
      const script = `-- FETCH WRAPPER PREVIEW\nlocal UID = "SRCID_PLACEHOLDER"\nlocal TOKEN = "TOKEN_PLACEHOLDER"\nlocal ORIGINAL_SRC = "${orig}"\n\n-- wrapper will request ORIGINAL_SRC?uid=UID&t=TOKEN and run the returned loader`;
      document.getElementById('previewText').textContent = script;
    }
    document.getElementById('previewBox').style.display = 'block';
  };

  // Quick fetch script
  document.getElementById('quick_fetch').onclick = async () => {
    const src = document.getElementById('quick_src').value;
    const key = document.getElementById('quick_key').value;
    if (!src || !key) return alert('Provide src_id and key');
    try {
      const respText = await api(`/api/script/${encodeURIComponent(src)}?key=${encodeURIComponent(key)}`, { headers: { 'Accept': 'text/plain' }});
      downloadText(respText, `personalized_${src}.lua`);
      document.getElementById('responseBox').textContent = `Fetched script for ${src}`;
    } catch(e) {
      document.getElementById('responseBox').textContent = 'Error: ' + (e.error || JSON.stringify(e));
    }
  };

  function downloadText(text, filename){
    const blob = new Blob([text], { type:'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // test redeem
  document.getElementById('test_redeem').onclick = async () => {
    const key = document.getElementById('test_key').value;
    const discord = document.getElementById('test_discord').value || '';
    const hwid = document.getElementById('test_hwid').value || '';
    if (!key || !discord || !hwid) return alert('Provide key, discord id, hwid');
    try {
      const j = await api('/api/redeem', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ key, discord_id: discord, hwid })});
      document.getElementById('responseBox').textContent = JSON.stringify(j, null, 2);
      // if returned script_endpoint, display it
      if (j.script_endpoint) {
        document.getElementById('responseBox').textContent += `\nScript endpoint: ${j.script_endpoint}\nsrc_id: ${j.src_id || '(none)'}`;
      }
    } catch(e) {
      document.getElementById('responseBox').textContent = 'Error: ' + (e.error || JSON.stringify(e));
    }
  };

  // redeem & fetch script (test)
  document.getElementById('test_fetch_script').onclick = async () => {
    const key = document.getElementById('test_key').value;
    const discord = document.getElementById('test_discord').value || '';
    const hwid = document.getElementById('test_hwid').value || '';
    if (!key || !discord || !hwid) return alert('Provide key, discord id, hwid');

    try {
      const j = await api('/api/redeem', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ key, discord_id: discord, hwid })});
      document.getElementById('responseBox').textContent = JSON.stringify(j, null, 2);
      if (j.src_id) {
        const src = j.src_id;
        // fetch the script
        const scriptText = await api(`/api/script/${encodeURIComponent(src)}?key=${encodeURIComponent(key)}`, { headers: { 'Accept': 'text/plain' }});
        downloadText(scriptText, `personalized_${src}.lua`);
        document.getElementById('responseBox').textContent += `\nDownloaded personalized script for src: ${src}`;
      }
    } catch(e) {
      document.getElementById('responseBox').textContent = 'Error: ' + (e.error || JSON.stringify(e));
    }
  };

  // docs link placeholder
  document.getElementById('open_docs').onclick = () => alert('Docs: Use the API endpoints /api/admin/* and /api/redeem /api/script/:src as described in README.');

</script>
</body>
</html>
